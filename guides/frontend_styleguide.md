# Frontend StyleGuide and Coding Conventions

Единообразие существенно снижает когнитивную сложность восприятия кода.
Все наши проекты должны быть в одном стиле во всем - наименование, структура и тд.
Единообразие и следование правилам важнее чем то, что гласят отдельные правила.

Стараемся большую часть работы по проверки качества кода свалить на софт. Люди ошибаются постоянно, компьютеры - никогда.
Поэтому eslint, prettier, etc - наше все.

## Linting

За основу берем [конфигурацию от typescript book](https://github.com/basarat/typescript-book/blob/master/docs/styleguide/styleguide.md).

### [eslint-config-bestdoctor](https://github.com/best-doctor/eslint-config-bestdoctor)
Используем во всех проектах, при необходимости добавляем специфичные для проекта правила/плагины (например штуки про react-native для мобилки).

Если проект не полностью соответствует конфигу из-за легаси - временно переводим сломанные правила в `warn`.
По мере рефакторинга все должно быть поправлено и все исключения убраны.

Отключение правила линтинга имеет исключительный характер и должно производиться точечно (для строки), сопровождаться комментарием о причинах отключения и, в идеальном мире, сопровождаться ссылкой на таску на починку

## Formatting

За него отвечает prettier с такими вот настройками:

```json
{
  "printWidth": 120,
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5"
}
```

## Project structure

### Общие положения

Мы используем компонентный подход и пытаемся сделать структуру проекта максимально модульной.

В `src` проекта находятся/могут находиться папки:

- `entities` - корневая директория кода относящегося к бизнес-сущностям
  + `[Имя_сущности]` - корневая директория для конкретной бизнес-сущности (e.g. `User`)
    * `components` - компоненты отвечающие за view слой сущности;
    * `contexts` - контексты используются **только** в случае необходимости глобального использования сущности для избегания пропс-дриллинга, директория содержит всё относящееся к контекстам;
    * `hooks` - хуки сущности, содержит базовые хуки для работы с api (`queries`, `mutations`) и хуки специфичные для сущности. Инвалидаторы и фабрика ключей кэша запросов также находятся здесь;
    * `pages` - компоненты отвечающие за отображение страниц, относящихся к сущности.
- `services` - глобальные вещи, по смыслу схожие с идеологией синглтонов (существует в единственном экземпляре, к которому есть подключения из различных мест), примеры:
  * `auth` - всё, что связано с авторизацией - хуки, компоненты вывода информации об пользователе, страница с ошибкой о недостатке прав;
  * `api` - слой подключения к внешнему api, хранящий необходимые настройки, не путать с конкретными запросами, которым место в entities;
- `features` - корневая директория для кода не относящегося к конкретной бизнес сущности, содержит в себе директории фичей, структуры, которых идентичны структуре в `entities`. Примеры фичей: 
  * `text` - функции плюрализации, компоненты вывода заголовков, абзацев и т.д.
  * `date` - функции и константы для работы с датами (форматирование, парсинг, маски)

В корне проекта могут лежать базовые вещи типа инстанса истории браузера, роутер, тема визуализации, но лишь пока они атомарны, в случае наращивания функционала следует перенести в features

#### Реэкспорты
Индексные реэкспортирующие файлы по умолчанию - зло.
Допускаются только в директориях из которой по логике в большинстве случаев используется большая часть компонентов. Было бы хорошо иметь api к сущностям и фичам в виде индексных реэкспортов, но пока нет tree-shaking'а нормально обрабатывающего такие случаи - бандлы раздуваются и приложение затормаживается.
Также реэкспорты делают более сложным нахождение мёртвого кода (он тоже зло т.к. тратит время на сопровождение).

### Хранение данных и стейта
#### Работа с backend'ом
Для работы с бэкендом используется [react-query](https://www.npmjs.com/package/react-query)

##### Ключи кэширования
Полезная статья по работе с ключами кэша: [Effective React Query Keys](https://tkdodo.eu/blog/effective-react-query-keys)

Для генерации ключей кэшей запросов используется фабрика ключей с поддержкой единичных и списочных запросов.

Код фабрики генерации ключей:
```TypeScript
export function getRequestsKeys<TListKeys, TItemKeys = string>(entityName: string) {
  return {
    all: [entityName] as const,
    lists: [entityName, 'list'] as const,
    list: (keys: TListKeys) => [entityName, 'list', keys] as const,
    items: [entityName, 'item'] as const,
    item: (keys: TItemKeys) => [entityName, 'item', keys] as const,
  }
}
```
где:
- `entityName` - название сущности
- `TListKeys` - интерфейс параметров запроса списка, обязательный параметр
- `TItemKeys` - интерфейс запроса единичной сущности, опционально, по умолчанию - строка

###### Пример использования

Создание фабрики ключей:
```TypeScript
interface ListEntityParams {
  search: string;
  page: number;
  per_page?: number;
}

const entityRequestsKeys = getRequestsKeys<ListEntityParams>('entity')
```

Использование в запросах:
```TypeScript
/**
 * Получение единичной сущности
*/
function useEntity(uuid: string) {
  return useQuery({
    queryKey: entityRequestsKeys.item(uuid),
    queryFn: () => getEntity(uuid),
    staleTime: 60_000,
  })
}

/**
 * Получение списка сущностей
 */
function useEntityList(params: ListEntityParams) {
  return useQuery({
    queryKey: entityRequestsKeys.list(params),
    queryFn: () => getEntityList(uuid),
    staleTime: 60_000,
  })
}
```

Инвалидация кэшей:
```TypeScript
const client = useQueryClient()
// Инвалидация всех запросов сущности
client.invalidateQueries(entityRequestsKeys.all)
// Инвалидация всех списков
client.invalidateQueries(entityRequestsKeys.lists)
// Инвалидация определенного запроса списка
client.invalidateQueries(entityRequestsKeys.list(params))
// Инвалидация всех единичных запросов сущности
client.invalidateQueries(entityRequestsKeys.items)
// Инвалидация единичного запроса сущности
client.invalidateQueries(entityRequestsKeys.item(id))
```

##### Написание хуков запросов

Для создания своего хука используется вариант useQuery с передачей всех параметров в виде объекта, данная форма показала себя максимально лаконичной и гибкой

Пример обычного запроса:

```TypeScript
import { useQuery, UseQueryOptions } from 'react-query'

// интерфейс ошибки запроса
type FetchError = {}
type Response = {
  user: {
    name: string
    mail: string
  }
}
type Options<Result> = Partial<UseQueryOptions<Response, FetchError, Result>>

// Result - будет вычислен в случае указания нормализатора в options
export function useUser<Result = Response>(uuid: string, options?: Options<Result>) {
  return useQuery<Response, FetchError, Result>({
    queryKey: userRequestsKeys.item(uuid),
    queryFn: () => getUser(uuid),
    // время жизни кэша запроса, зависит от характера данных
    staleTime: 60_000,
    ...options,
  })
}
```

Подгружаемые запросы списков реализуются аналогичным образом с использованием useInfiniteQuery:
```TypeScript
import { useInfiniteQuery, UseInfiniteQueryOptions } from 'react-query'

// интерфейс ошибки запроса
type FetchError = {}
type Response = {
  user: {
    name: string
    mail: string
  }
}[]
type Options<Result> = Partial<UseInfiniteQueryOptions<Response, FetchError, Result>>

export function useUser<Result = Response>(params: SearchUsersParams, options?: Options<Result>) {
  return useInfiniteQuery<Response, FetchError, Result>({
    queryKey: userRequestsKeys.list(params),
    queryFn: () => getUsers(params),
    staleTime: 60_000,
    ...options,
  })
}
```

Мутации создаются тоже аналогичным образом:
```TypeScript
import { useMutation, MutationOptions } from 'react-query'

// интерфейс ошибки запроса
type FetchError = {}
type Response = {
  user: {
    name: string
    mail: string
  }
}
type Options = MutationOptions<Response, FetchError, Result>

export function useUpdateUser<Result = Response>(params: UpdateUserParams, options?: Options<Result>) {
  const queryClient = useQueryClient()

  return useMutation<Response, FetchError, Result>({
    mutationFn: () => updateUser(params),
    onSuccess: () => {
      // инвалидируем все списки, если не знаем в какие именно входит данная запись
      queryClient.invalidateQueries({ queryKey: userRequestsKeys.lists })
      // инвалидируем запрос этой записи
      queryClient.invalidateQueries({ queryKey: userRequestsKeys.item(params.id) })
    },
    ...options,
  })
}
```

##### Правила наименования хуков запросов
- Запрос единичной записи - `use<EntityName>`, например: `useUser`
- Специфический запрос записи - `use<EntityName><Specific>`, например: `useUserByEmail`
- Запрос списка записей - `use<EntityNames>List`, например `useUsersList`
- Запрос подгружаемого списка записей - чаще всего используется для запросов поиска, поэтому - `useInfiniteSearch<EntityNames>`, например: `useInfiniteSearchUsera`. Если это не запрос поиска, то слово Search опускается и добавляется List - `useInfinite<EntityNames>List`/`useInfiniteUsersList`

##### Правила наименования хуков мутаций
Общий паттерн наименования - `use<Action><EntityName><?Field>`
Action - производимое действие, чаще всего одно из update, create, remove
Field - указание на поле, если действие производится только над ним

Примеры:
- Хук создания записи - `useCreateUser`
- Хук удаления записи - `useRemoveUser`
- Хук изменения всей записи - `useUpdateUser`
- Хук изменения отдельного поля записи - `useUpdateUserName`

#### Стейт формы
Раздел в разработке

Для хранения стейта формы используется библиотека [react-hook-form](https://www.npmjs.com/package/react-hook-form)

#### Глобальные стейты
По возможности избегаются. Всё что может быть локальным - делается локальным. Исключениями могут быть только вещи, которые действительно используются глобально - авторизация, стейт виджета, используемого на множестве страниц и т.д., для них допускается использование контекста.

## Names
### Общее

Название должно быть семантичным бизнес логике, то есть обозначать то, чем занимается данная сущность.
Например, компонент для переключения видимости пароля может называться `TogglePasswordVisibilityButton`.
И не может `EyeIconButton`.
Потому что:

1. Не понятно что именно делает данный элемент.
1. Название зависит от контента/стилей, если вместо картинки с глазом появится картинка с камерой, например, нужно переименовывать компонент.

Понятность названия важнее длины, красоты и грамматической правильности.

### Конкретное

#### Функции
Название функции всегда начинается глаголом.

- get\* - возвращает используемое значение.
- validate*, check* - возвращает bool.
- format\* - преобразовывает данные.
- set\* - устанавливает значение в стейте/сторе.
- handle\*(Change/Click/Press) - для функций оберток над set передаваемых в пропсы.
  
Исключение - функциональные пропсы компонентов начинаются на on\*, для отделения их от функций созданных в компоненте и консистентности со стандартными html-пропсами

#### Переменные
Переменная всегда существительное.

#### Флаги
Boolean - с префиксами is, has, can, has, have, was etc.

#### Коллекции
Коллекции - множественное число, например errors.

Про коллекции свойств:

- usersPhoneNumbers - номера телефонов юзеров
- userPhoneNumbers - номера телефонов юзера
- usersPhoneNumber - номер телефона юзеров?

Количество сущностей - постфикс Number

Число обозначающее порядковый номер - постфикс Index

Постфикс data - чтобы отличать данные с формы от объекта (например с бека).

Действие не должно смешиваться со состоянием - on-off, closed-open.

## Важные вещи

### Понятность

Код пишется один раз, а читается многократно. Понятность - важнейшее качество кода, важнее красоты, элегантности,
микрооптимизации и тд. Код должен быть прост и очевиден.

### Single responsibility

Одна функция выполняет одну задачу, но делает это хорошо.

- Если в названии функции есть and - возможно она слишком много на себя берет и ее нужно разделить?
- Если функция принимает boolean параметр, возможно он переключает ее поведение и ее нужно разделить?
- Если функция в несколько сотен строк кода, возможно стоит вычленить часть логики в другие функции?

#### Параметры функции

Если параметров один или два то можно передавать обычно ( `function foo(a: number, b: number)` ), иначе оборачиваются в объект ( `function foo({ a: number, b: number, c: string })` ). Допускается оборачивание в объект единственного аргумента, если планируется или допускается расширение функционала/конфигуриремости.

#### Композиция функций

Как правило, если функция принимает слишком много параметров - нужно ее разбивать. Исключения - функции не содержащие логику в себе, например для передаче кучи полей на бек в одном запросе и тд. При этом функция может содержать асинхронный код который должен выполниться в момент ее вызова. То есть мы не можем заранее получить какой-то фрагмент готовых данных и просто передать его в эту функцию. В данном случае можно добавить в функцию стандартные аргументы onSuccess и onError, принимающие или не принимающие результаты выполнения функции в зависимости от необходимости.

### Комментарии

Комментарии - зло. Они могут устаревать, если их забыли поправить после изменения логики, они могут быть неверными, они могут быть слишком очевидными или недостаточно детальными. Самодокументируемый код - наше все. Если по коду функции не понятно что там происходит - значит это плохой нейминг функции и переменных.

Возможно стоит разбить логику на части и вынести их в функции с понятными названиями?
Даже если функция изначально была небольшой - это увеличит понятность.

Исключения - комментарии с объяснением причин отключения линтинга (см. выше) и отметки об найденном техдолге или точках ростах (комментарии `// TODO`) - если не получается сделать лучше прямо сейчас, то стоит хотя бы отметить и записать свои мысли.
Опасность: стоит следить за количеством комментариев `TODO`, если команда не уменьшает их количество и только генерирует новые, то нужно вводить инструменты контроля количества и выполнения (e.g. можно добавить ограничение, что каждый `TODO` обязан иметь ссылку на тикет на выполнения)

### Отзывчивость и понятность интерфейса

Нельзя оставлять юзера без фидбека. Если что-то происходит, юзер должен об этом знать.
Пустой экран пока что-то грузится - зло. Нужно показать хоть текстовый лоадер.
Пустой экран когда что-то упало - зло. Нужно показать хотя бы текст "Что-то пошло не так, обнови страницу"
