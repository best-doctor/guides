# Гайдлайны для тестов

## Для кого

Многие правила подразумевают, что их читает Python-разработчик, а не тестер и не фронтендер. Так что, например, отделу QA эти правила не подойдут.

## Мотивация

Тесты, как и любой код, нужно поддерживать в чистоте. Один из способов улучшить сопровождаемость тестов — ввести список правил. Правила упростят ознакомление с существующими тестами и подскажут, как писать новые.

Эти гайдлайны являются _вводными_. Добавлять сразу много строгих правил сложно и непрактично, лучше начать с малого.

## Отношение к другим документам

Во время написания тестов соблюдается [Python Styleguide](https://github.com/best-doctor/guides/blob/master/guides/python_styleguide.md).

## Куда класть тесты

Тесты для `bestdoctor/models/clinic.py` должны лежать в `bestdoctor/tests/test_models/test_clinic.py`. Более общее правило: тесты для `bestdoctor/<foo>/<bar>.py` лежат в `bestdoctor/tests/test_<foo>/test_<bar>.py`.

Тесты для `mail/signals.py` должны лежать в `mail/tests.py` или `mail/tests/test_signals.py`. Более общее правило: тесты для `<foo>/<bar>.py` находятся в `<foo>/tests.py` или в `<foo>/tests/test_<bar>.py`.

## Два вида тестов

Разработчикам надо тестировать две вещи:

1. Что фича работает
2. Что функции и методы, составляющие фичу, работают как надо

А соответственно нужны два вида тестов:

1. Относительно долгие, проверящие фичу целиком
2. Несколько быстрых юнит-тестов, тестирующие отдельные составляющие фичи

## `selenium` vs `django.test.Client`

Если фича тестируется полностью, мы используем `django.test.Client`. Если `django.test.Client` оказывается недостаточно, переходим на `selenium`. Пока обходились без него.


## Скорость выполнения

Мы пока не обращаем внимания на скорость выполнения, но избегаем слишком долгих тестов.

## `success_case` и `error_case`

`success_case`-тест отвечает на вопрос «как должен вести себя код при корректном инпуте». На каждую фичу и её составляющую должен приходится `success_case`-тест.

Если фича/составляющая должна как-то особо обрабатывать некорректный ввод, под неё пишется `error_case`-тест.

## Параметризация

Чтобы избегать дубликации кода при написании тестов, мы их параметризируем с помощью `pytest.parameterize`. Благодаря этому `success_case`-тестов редко бывает больше одного.

Бывает так, что из параметров непонятно, какое поведение тестировалось. Тогда группы параметров можно подписать с помощью [параметра ids](https://docs.pytest.org/en/latest/example/parametrize.html#different-options-for-test-ids).

## `pytest.mark.xfails` vs `pytest.raises`

Мы используем `pytest.raises`, чтобы показать, что тест проходит только если поднимается исключение.

Мы используем `pytest.mark.xfails` в единственном случае: когда мы написали тесты для новой фичи, а код — нет. Коммит с такими тестами сломает билд, если их не пометить `pytest.mark.xfails`.

## `unittest.mock` vs `factory_boy`

Мы не используем `unittest.mock`. Вместо него наши тесты, даже маленькие, ходят в базу данных к объектам, сгенерированным с помощью `factory_boy`. Нам так привычнее.

## Как обращаться с фабриками

Новые фабрики добавляются в `bestdoctor/factories.py` и регистрируются в `bestdoctor/tests/conftest.py`. Далее они доступны тестам в качестве параметров.

Если тестируемый код находится не в папке `bestdoctor`, то правила расположения `factories.py` и `conftest.py` такие же, как и в случае с тестами (см. выше).

Чаще всего мы не делаем фикстуры из фабрик.

**Плохо:**

```python
@pytest.fixture()
def n_patients_factory(patient_factory):
    def generate_n_patients(patients_num, data_only=False):
        if data_only:
            return patient_factory.build_dict_batch(patients_num)
        return patient_factory.create_batch(patients_num)
```

Такие вещи лучше реализовывать в виде метода на фабрике. Это позволит избежать дубликации усилий.

## Порядок аргументов теста

Сначала идёт `django.test.Client`, потом параметры теста, затем фабрики.

## Как тестировать интеграции со сторонними сервисами

Наши тесты отправляют реальный запрос на тестовый аккаунт.

Допустим, мы тестируем функцию, присылающую уведомления в Slack — `send_slack_notification`. Тест будет написан так, чтобы сообщение реально приходило на тестовый канал в Slack.

Когда нам это надоест, будем думать подбирать альтернативы.

## Шаблон теста

```python
@pytest.mark.parametrize(
    'param1, param2, ...',
    [
        (value11, value12, ...),
        (value21, value22, ...),
        (value31, value32, ...),
        (..., ..., ...),
    ]
)
@pytest.mark.django_db
def test_foo_bar_success_case(param1, param2, ..., foo_factory, ...):
    arrange()
    
    act()
    
    assert ...
```

[Статья про паттерн AAA](https://medium.com/@pjbgf/title-testing-code-ocd-and-the-aaa-pattern-df453975ab80)

Тест будет функциональным или юнитом в зависимости от того, какой код у него в `arrange`, `act` и `assert`.

## Как дорабатывать документ

Это не окончательная версия документа. Дорабатывать его можно в репозитории [на Гитхабе](https://github.com/best-doctor/guides). Идеи — в ишьюс, реализация — в пулл-реквесты