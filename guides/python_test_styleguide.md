# Гайдлайны для тестов

## Для кого

Эти правила подразумевают, что их читает Python-разработчик, а не тестер или фронтендер. Так что отделу QA эти правила
не подойдут.

## Мотивация

Тесты, как и любой код, нужно поддерживать в чистоте. Один из способов улучшить сопровождаемость тестов — ввести список
правил. Правила упростят ознакомление с существующими тестами и подскажут, как писать новые.

Эти гайдлайны являются _вводными_. Добавлять сразу много строгих правил сложно и непрактично, лучше начать с малого.

## Отношение к другим документам

Во время написания тестов соблюдается
[Python Styleguide](https://github.com/best-doctor/guides/blob/master/guides/python_styleguide.md).

## Дисклеймер

Мы пишем тесты с использованием `pytest` и плагинов для него. Рудименты, вроде `unittest.TestCase`, под запретом.

## Два вида тестов

Разработчикам надо тестировать две вещи:

1. Что фича работает
1. Что функции и методы, составляющие фичу, работают как надо

А соответственно нужны два вида тестов:

1. Интеграционные тесты, которые тестируют фичу целиком и проверяют успешность интеграции разных компонентов системы
1. Юнит-тесты - легковесные тесты, проверяющие отдельные методы и функции

## Куда класть тесты

Тесты для `mail/signals.py` должны лежать в `mail/test_integration/tests.py` или `mail/tests/test_integration/test_signals.py`.

Более общее правило: тесты для `<foo>/<bar>.py` находятся в `<foo>/test_<test_type>/tests.py`
или в `<foo>/tests/test_<test_type>/test_<bar>.py`.

## `selenium` vs `django.test.Client`

Чтобы протестировать фичу полностью, мы используем `django.test.Client`.

Мы не используем `selenium` по двум причинам:

1. Он тяжёлый
1. Не существует сценариев, в которых нам требуется его функциональность

## Скорость выполнения

Мы пока не обращаем внимания на скорость выполнения, но избегаем слишком долгих тестов.

## `success_case` и `error_case`

`success_case`-тест отвечает на вопрос «как должен вести себя код при корректном инпуте». На каждую фичу и её
составляющую должен приходится `success_case`-тест.

Если фича/составляющая должна как-то особо обрабатывать некорректный ввод, под неё пишется `error_case`-тест.

## Параметризация

Чтобы избегать дублирования кода при написании тестов, мы их параметризируем с помощью `pytest.parameterize`.
Благодаря этому `success_case`-тестов редко бывает больше одного.

Бывает так, что из параметров непонятно, какое поведение тестировалось. Тогда группы параметров можно подписать с
помощью [параметра ids](https://docs.pytest.org/en/latest/example/parametrize.html#different-options-for-test-ids).

## `pytest.mark.xfail` vs `pytest.raises`

Мы используем `pytest.raises`, чтобы показать, что тест проходит только если поднимается исключение.

Мы используем `pytest.mark.xfail` в единственном случае: когда мы написали тесты для новой фичи, а код — нет. Коммит
с такими тестами сломает билд, если их не пометить `pytest.mark.xfail`.
При использовании `xfail` также обязательно указывать параметр `reason`, чтобы облегчить менеджмент помеченных тестов
и не устраивать бардак из бесполезных тестов.

## `mock`

Мы используем фикстуру `mocker` из плагина `pytest-mock` для патчинга походов в сеть и асинхронных задач в легковесных юнит-тестах.

## `factory_boy`

Мы используем фабрики из `factory_boy` для генерации тестовых Django ORM сущностей и облегчения сетапа тестов.

## Куда класть фабрики и фикстуры

Новые фабрики добавляются по тем же правилам, что и тесты (см. выше) и регистрируются в корневом файле `conftest.py`,
чтобы быть доступными в любом тестовом модуле.

Фикстуры должны располагаться в `conftest.py` соответствующего уровня. Переиспользуемые фикстуры нужно класть как можно выше.

## Фикстуры и фабрики

Чаще всего мы не делаем фикстуры из фабрик.

**Плохо:**

```python
@pytest.fixture()
def n_patients_factory(patient_factory):
    def generate_n_patients(patients_num, data_only=False):
        if data_only:
            return patient_factory.build_dict_batch(patients_num)
        return patient_factory.create_batch(patients_num)
```

Такие вещи лучше реализовывать в виде класс-метода на фабрике. Это позволит избежать дублирования усилий.

**Хорошо:**

```python
@classmethod
def create_batch_with_params(cls, patients_num: int, data_only: bool = False) -> List[Patient]
    if data_only:
        return cls.build_dict_batch(patients_num)

    return cls.create_batch(patients_num)
```

## Аргументы и ассерты теста

Тесты нужно держать в чистоте и не перегружать зависимости. Поэтому стоит следить за количеством аргументов теста.
Хорошая тестовая функция должна иметь не более 5-6 аргументов в сингнатуре.
В противном случае стоит подумать над разделением проверок.

То же самое касается количества ассертов в тесте.
Большое количество ассертов перегружает тест, снижает его читаемость и полезность.

При инстанцировании фабрик указываем только те аргументы, которые нужны для текущего теста.
Не указываем ненужные и не полагаемся на дефолты в фабрике, если оно нужно в конкретном тесте.

## DRY и KISS

Тесты, как и любой код, должны придерживаться стайлгайдов и лучших практик.
Для этого мы выносим переиспользуемые вещи в фабрики и фикстуры, используем хелперы.

Например, частым действием в тестах является присвоение и сохранение в базу какого-то значения:

```python
model_instance.field_name = 'foo'
model_instance.save()
```

Такие вещи лучше выносить в фабричные методы. Это даст лучший API, повысит читаемость и сократит количество бойлерплейта.

```python
value = 'foo'
model_instance.set_another_value_and_save('field_name', value)
```

## Как тестировать интеграции со сторонними сервисами

Мы используем интеграционные тесты для проверки подобных сценариев.

Допустим, мы тестируем функцию, присылающую уведомления в Slack — `send_slack_notification`. Тест будет написан так,
чтобы сообщение реально приходило на тестовый канал в Slack.

## Как тестировать функциональность, основанную на фичафлагах

 Для фичафлагов мы используем библиотеку [waffle](https://github.com/django-waffle/django-waffle). Библиотека
 поставляется с декораторами, которые устанавливают флаг до прогона логики теста. Почитать об их использовании
 можно в [документации](https://waffle.readthedocs.io/en/stable/testing/automated.html).

 При добавлении новой фичи, закрытой за фичафлагом, пишется функциональный/юнит тест на эту логику с нужным декоратором
 с параметром `active=True`. Если на старую логику тест существует, то он оборачивается в декоратор с параметром
 `active=False`. Этот подход позволяет быстро приводить в порядок тесты при выпиливании протестированных фичафлагов.

## Шаблон теста

Мы придерживаемся паттерна ААА в структуре тестов.
Соблюдать эту структуру важно, так как это увеличивает читаемость, а следовательно увеличивает полезность теста.

[Статья про паттерн AAA](https://medium.com/@pjbgf/title-testing-code-ocd-and-the-aaa-pattern-df453975ab80)

Пример:

```python
@pytest.mark.parametrize(
    'param1, param2, ...',
    [
        (value11, value12, ...),
        (value21, value22, ...),
        (value31, value32, ...),
        (..., ..., ...),
    ]
)
@pytest.mark.django_db
def test_foo_bar_success_case(param1, param2, ..., foo_factory, ...):
    arrange()

    act()

    assert ...
```

## Как дорабатывать документ

Это не окончательная версия документа. Дорабатывать его можно в репозитории
[на Гитхабе](https://github.com/best-doctor/guides). Идеи — в ишьюс, реализация — в пулл-реквесты.

