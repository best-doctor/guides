# REST API BestDoctor

## Общие принципы построения API

1. API следует принципу HATEOAS, генерируя необходимые ссылки на ресурсы. Клиент опирается на доступные в ответе
   ресурсы, а не на хардок ссылок API.
1. API возвращает использует `HTTP` статусы в ответах. Успешная обработка запроса - `20x`, редирект - `30x`, ошибка в запросе
   или при его обработке - 4xx.
1. API информативен. Для успешной обработки запроса помимо ответа API может вернуть параметры запроса.  В случае ошибки
   возвращается описание и массив ошибок валидатора, может быть ссылка на документацию по API и рекомендации как ошибки
   избежать.
1. Работать с API будут не столько машины, сколько разработчики, и мы хотим максимально им в этом помочь.
1. API использует стандартные HTTP-заголовки. Версионирование, запрос конкретных feature, желаемый типа данных, передача
   некоторых параметров типа TimeZone - все идет в заголовках и не замусоривает тело запроса повторяющимися параметрами.
1. API быстрый. Ответ должен генерироваться максимум за 250мс, а тяжелые операции должны проводиться асинхронно.
1. API это не (только лишь) CRUD над ORM, сущности API должны отражать бизнес-процессы. В дополнение к этому может
   существовать и низкоуровневый слой API для манипуляции с базой.

### Формат запроса и ответа

Все запросы и ответы передаются в формате json. Ответ содержит поле `data` в случае успешной обработки (код `200 OK`,
`201 Created`), может не содержать тела (код `204 No Content`).

```http request
GET /patients/me HTTP/1.1
Accept: application/vnd.bestdoctor.v1.verbose+json

HTTP/1.1 200 OK
{
  "data": {
    "url": "/patients/51413",
    "patient_id": 51413,
    "name": "John",
    "surname": "Doe"
  },
  "meta": null,
  "query": {"patient_id": "me"}
}
```

Кроме поля data ответ может содержать следующие поля:

* `meta` - дополнительная информация по запросу, например, размер выборки для коллекций
* `query` - разобранный запрос, включая дефолтные значения необязательных полей, не заданных в запросе. Отражает полные
  входные данные обработчика запроса.

Каждый объект содержит ссылку на себя в атрибуте `url` и ссылки на связанные ресурсы в атрибутах, имеющих суффикс `_url`.

В случае ошибки ответ содержит поле `message` с человекочитаемым описанием проблемы, массив `errors` может содержать
подробности от валидаторов.

```http request
POST /patients/me HTTP/1.1

name=JOHN

HTTP/1.1 401 Authorization Required
{"message": "You should be logged in"}
```

Коды ответа `200`, `201`, `204` возвращаются для успешно обработанных запросов. При ошибках обработки 400, ошибках приложения
`420`, ошибках валидации `422`, ошибках доступа `401`, `403`, `404` (когда необходимо).

### Передача параметров

Параметры для GET-запросов передаются в url и в query string после `?`. Остальные запросы принимают параметры в строке адреса и в
теле запроса.

```http request
GET /patients?page=1 HTTP/1.1
```

```http request
POST /patients/51413 HTTP/1.1

{"name": "Vasiliy"}
```

### Ошибки обработки запроса

В зависимости от схемы ответ с сообщением об ошибке может содержать поля:

* `message` - человекочитаемое сообщение об ошибке (для разработчика или пользователя клиентского приложения)
* `int_code` - числовой код ошибки для автоматической обработки клиентскими приложениями
* `suppress_message` - флаг: можно ли не показывать сообщение пользователю клиентского приложения
* `errors` - массив ошибок с указанием:
    * `resource` - ресурса
    * `field` - поля запроса
    * `code` - буквенно-цифрового кода ошибки
    * `message` - сообщения пользователю

### Ошибка `400 Bad Request`
  
При ошибке разбора запроса (передан невалидный json) возвращается `400 Bad Request`

```http request
PATCH /patients/me HTTP/1.1
Host: api.bestdoctor.ru
Authorization: Token hexdigest-token-string

name=JOHN

HTTP/1.1 400 Bad Request
{"message": "Body should be a valid json"}
```

### Ошибка `420 Going To Hell Error`

Все ошибки, возникающие при обработке валидного запроса, возвращаются с кодом `420 Going To Hell Error`. Что-то пошло не
так с точки зрения сервера, но это не фатальная ошибка сервера типа `500`, а ошибка, предусмотренная бизнес-логикой.

```http request
POST /patients/me/visits HTTP/1.1
Authorization: Token hexdigest-token-string

{"clinic_id": 54321, "timeslot": "2020-04-15T10:45:00+03:00"}

HTTP/1.1 420 Going To Hell Error
{
  "message": "Выбранное время для записи в клинику недоступно",
  "int_code": 90210,
  "suppress_message": false,
  "errors": [
    {
      "resource": "Clinic",
      "code": "timeslot_is_busy",
    }
  ]
}
```

### Ошибка валидации запроса `422 Unprocessable Entity`

При ошибке валидации запроса - `422 Unprocessable Entity` + массив `errors` с описанием ошибок валидации.

```http request
PATCH /patients/me HTTP/1.1
Host: api.bestdoctor.ru
Authorization: Token hexdigest-token-string

{"patient_id": 12345, "phone": "сотовый"}

HTTP/1.1 422 Unprocessable Entity
{
  "message": "Validation error",
  "errors": [
    {
      "resource": "Patient",
      "field": "patient_id",
      "code": "readonly_field"
      "message": "Id пациента нельзя редактировать",
    },
    {
      "resource": "Patient",
      "field": "phone",
      "code": "wrong_phone_format"
      "message": "Телефон должен содержать хотя бы одну цифру",
    }
  ]
}
```

### Аутентификация клиента

Данные для аутентификации клиента передаются в заголовке вида `Authorization: (basic|bearer|token) <value>`

1. Basic-схема может использоваться в обычном режиме (login:password) для авторизации некоторых приватных методов API,
   как базово поддерживаемая в url схема
1. Basic-схема может использоваться в режиме login:OAuth для работы с OAuth и разделением прав разных приложений
   (сайт, мобилка, премиальная мобилка)
1. Bearer-схема может использоваться с сессионным токеном JWT
1. Token-схема может использоваться для авторизации приложений по OAuth

Отсутствие заголовка аутентификации может повлечь одно из следующего:

* Успешный ответ, но явную или неявную фильтрацию/ограниченный объем ответа (к примеру, список публично доступных
  ресурсов может быть меньше, чем для пациента или HR).
* Ошибку `401 Authorization Required`

При успешной аутентификации клиента, но нехватке прав на конкретный запрашиваемый ресурс, API обычно отвечает `403 Not
Authorized`. В некоторых случаях стоит возвращать `404 Not Found,` чтобы скрыть сам факт наличия конкретного ресурса
(клиенту, не имеющему должных прав, обращения к `/clients/nonexistent` и `/client/existing` должны оба вернуть `404`).

### Паджинация (страничный вывод)

Максимальный размер страницы данных, которую возвращает API за один запрос, ограничен сервером, и может указываться в
параметре запроса `per_page` (дефолт 20, максимум 200). В ответе в разделе `meta` содержатся ссылки `url`, `next_url`,
`prev_url` и `last_url` на текущую, следующую, предыдущую и последнюю страницы набора данных. Поле `page_tmpl_url`
содержит шаблон для формирования url страницы по её номеру.

Чтобы скачать полный набор данных, клиенту следует запрашивать следующую страницу по адресу из `meta.next_url`, пока это
поле присутствует в ответе

В разделе `meta` может присутствовать поле `total`, обозначающие общее количество элементов в наборе, и поле `pages`,
обозначающее общее количество страниц (размера `per_page`) в наборе.

#### Постраничная паджинация

Страница выбирается параметром `page` (1, 2, 3, ...).

```http request
GET /patients?per_page=10 HTTP/1.1
Host: api.bestdoctor.ru
Accept: application/vnd.bestdoctor.v1.verbose+json

HTTP/1.1 200 OK
{
  "data": [{"url": "patient_id": 51413, "name": "John", "surname": "Doe"}, ...],
  "query": {"page": 1, "per_page": 10},
  "meta": {
    "total": 98, "pages": 10,
    "page_tmpl_url": "/patients?page={page}&per_page=10",
    "url": "/patients?page=1&per_page=10",
    "next_url": "/patients?page=2&per_page=10",
    "last_url": "/patients?page=10&per_page=10"
  }
}
```

#### Относительная паджинация

Некоторые ресурсы, например отсортированные по времени создания по убыванию, неудобно запрашивать по номеру страницы.
Так `page=1` может всегда указывать на самые последние записи, однако два запроса одной и той же страницы могут вернуть
разный набор данных, если он успел измениться.

Параметр `before=[object_uuid]` или `after=[object_uuid]` задаёт две вещи: граничный элемент и направление сортировки результата. 
Так, вариант с `before` запрашивает все элементы с датой создания строго меньше, чем у граничного, и отсортированные по убыванию этой даты, 
а вариант с `after` - все элементы с датой создания строго больше, чем у граничного, и отсортированные по возрастанию этой даты.

```http request
GET /chat/messages?per_page=10&before= HTTP/1.1
Host: api.bestdoctor.ru
Accept: application/vnd.bestdoctor.v1.verbose+json

HTTP/1.1 200 OK
{
  "data": [{"uuid": "UUID_FIRST", ...}, ..., {"uuid": "UUID_LAST", ...}],
  "meta": {
    "total": 98,
    "url": "/chat/messages?per_page=10&before=UUID_FIRST",
    "next_url": "/chat/messages?per_page=10&before=UUID_LAST",
    "prev_url": "/chat/messages?per_page=10&after=UUID_FIRST"
  }
}
```

Если `object_uuid` не задан, то выдается страница отсортированной коллекции и в `meta.url` указывается запрос
относительно первого элемента выборки.

### Версионирование API

Заголовок запроса `Accept` отвечает за выбор версии API, формата ответа, дополнительных опций API.

Базовый content-type для API это `application/json` - формат ответа json, кодировка UTF-8, все дополнительные опции и
версия API в дефолте.

Расширенный content-type выглядит так: `application/vnd.bestdoctor.[version].[option[-verbose]][+format]`

Параметр `format` всегда равен `json`.

Option позволяет выбрать различные варианты формирования ответа, передается в конкретный обработчик и может
интерпретироваться по-разному:

* `compact` - например, не подставлять связанные объекты, а оставлять их ссылками, либо не включать в выдачу
  дополнительные параметры
* `full` - включать в ответ все связанные объекты, дополнительные параметры
* `verbose` - включать в ответ исходный query или расширенную информацию в meta, красиво форматировать json для разработчика.

## Ресурсы

### Пациенты

#### Список разрешений

* `patient:view` - просмотр информации о пациенте
* …

#### Получить список пациентов

`GET /patients` - список пациентов, pageable

Параметры:

* `page`, `per_page` - настройки паджинации
* `qs` - строка поиска

Формат ответа:

```text
{
  "data": [
    {
      "url": url пациента,
      "patient_id": id пациента, обязательное поле,
      …
      "appeals_url": url списка обращений,
      "permissions": ["patient:view", "appeal:add_for_patient"]
    },
    …
  ]
}
```

#### Создать пациента

`POST /patients`

Параметры: ...

#### Получить детальную информацию о пациенте

`GET /patients/:patient_id`

Формат ответа:

```text
{
  "data": {
    "url": url пациента,
    "patient_id": id пациента, обязательное поле,
    …
    "program": {
       "url": url на программу, может отсутствовать,
       …
    },
    "slot": {
      "url": url на слот, может отсутствовать,
      …
    },
    "appeals_url": "/appeals/?patient=uuid" - url списка обращений,
    "permissions": ["patient:view", "appeal:add_for_patient"]
  },
}
```

#### Изменить информацию о пациенте

`PATCH /patients/:patient_id`

#### Удалить пациента

`DELETE /patients/:patient_id`

#### Создать обращение (связанный объект) по пациенту

`POST /patients/:patient_id/appeals`

#### Получить список обращений по пациенту

`GET /patients/:patient_id/appeals`

### Обращения

#### Список разрешений

* `appeal:add_for_patient` - создание обращения для конкретного пациента
* `appeal:add` - создание обращения

#### Получить список пациентов

`GET /appeals` - список пациентов, pageable

Параметры:

* `page`, `per_page` - настройки паджинации
* `qs` - строка поиска
* `patient` - uuid пациента для фильтрации

#### Создать обращение

`POST /appeals`

#### Получить детальную информацию по обращению

`GET /appeals/:appeal_id`

#### Обновить статус обращения

`PUT /appeals/:appeal_id/resolution`

#### Удалить статус обращения

`DELETE /appeals/:appeal_id/resolution`

#### Привязать обращение к пациенту

`PUT /appeals/:appeal_id/patient`

#### Получить список возможных результатов обращений

`GET /appeals_results`

Формат ответа:

```text
{
  "data": [
    {
      "id": 4,  // id результата
      "text": "наименование"
    },
  ]
}
```

#### Получить список категорий обращений

`GET /appeals_categories`

Формат ответа:

```text
{
  "data": [
    {
      "id": 12,  // id категории
      "parent": 4, // nullable ссылка на родительскую категорию,
      "text": "Жалобы"
    },
  ]
}
```
